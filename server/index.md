# Простой сервер

Настройка и обслуживание сервера для размещения веб проектов Python, с пользованием стека  Nginx + Gunicorn + Flask 



#### Дисклеймер (Disclaimer)

Это не универсальный метод создания веб серверов, а всего лишь частное представление того, как я это делаю для своих проектов. Поэтому как говорил одни кулинарный блогер:

> Знатоков того самого единственного правильного рецепта я попрошу сегодня не беспокоится.

Я не сторонник простых инструкций написанных по принципу - "скопируйте сюда этот файл, а сюда перепишите эту команду и нажмите ввод", однако и превращать эту статью в полный курс по всем аспектам затронутым в данном руководстве нет никакой возможности. Поэтому это будет некий средний вариант, где я буду показывать вам последовательность действий, попутно поясняя смысл введены команд, их ключей и параметров конфигурационных файлов. 

Я попробую разбить руководство на некие условные этапы, но четкой градации, как мне кажется достичь просто невозможно, в том числе из-за сильной интеграции сервисов и процессов друг с другом.
#### Задача

Нам необходимо настроить и запустить веб-сервер, на котором будет работать на проект написанный на языке Python. 

Какой проект? 
Да какой угодно. Веб сайт,  чат бот для Telegram или навык для Яндекс Алисы или Google Assitant`а, возможно сервис который ведет статистику пользователей вашей игры, либо даже просто статичная веб страничка, вот, например, с этой инструкцией.



#### Где.

В первую очередь это вопрос про деньги, поскольку техническая реализация у поставщиков плюс-минус одинаковая, ну как минимум однотипная. Поэтому ответ - где угодно, смотрите, что бы вам было комфортно по платежам.

Регистрация доменного имени. Я для этой цели воспользовался сервисом регистрации от AWS - Route 53. Просто потому, что я давно им пользуюсь, и это не первый домен который я у них регистрирую, вы же, построюсь, можете воспользоваться  услугами абсолютно любого регистратора.

Да, возможно кто то скажет - ну зачем я буду тратить лишние 10-20 долларов на доменное имя, если можно ходить на сервер просто по IP? И да, и нет. Современные правила предполагают использование зашифрованного соединения с нашим сервером, а сервисы предоставляющие сертификаты требуют именно зарегистрированное доменное имя, а не IP адрес. Иначе пользователь, в лучшем случае получит постоянные сообщения браузера об угрозе безопасности, а в худшем вообще не сможет зайти.

Итак, я только зарегистрировал имя  [blueoctopus.cc](), и на текущий момент на нем ни одной записи.

Саму виртуальную машину мы сделаем в Yandex Cloud. (Да, я все понимаю, но прошу не осуждать меня).

#### Ключи доступа.

Даже если это покажется странным, но начнем мы не с виртуальной, а с вашей домашней машины. Поскольку современные методы регистрации предполагают использование пары ключей **SSH** (**S**ecure **SH**ell), то мы их сразу и создадим, что бы при создании виртуальной машины сразу передать серверу открытую часть.

Итак, откроем консоль кликнув на соответствующую иконку, либо нажав комбинацию клавиш Ctrl + Alt + T (Command (⌘) + T) и сразу перейдем в каталог назначенный по умолчанию для хранения ключей.

```bash
cd .ssh
```

Если такой папки нет, то ее необходимо создать

```bash
mkdir .ssh
```

Ключи удобнее хранить в специально обозначенном каталоге, тогда не прийдется каждый раз при подключении указывать параметр с его размещением.

Если при попытке выполнить указанные выше действия вы столкнулись с ошибками, то вероятно вы используете ОС Wndows на своем десктопе.  Насколько мне известно, на Windows 10 c 2018 позволяет использовать SSH, только его необходимо отдельно установить.  Официальный сайт Microsoft говорит, что:

> OpenSSH можно использовать для подключения устройств с Windows 10  (версия 1809 и более поздние)
> Чтобы установить компоненты OpenSSH, сделайте следующее:
>
> 1. Откройте приложение Параметры, выберите элементы Приложения > Приложения и возможности, щелкните Дополнительные возможности.
> 2. Просмотрите этот список и определите, установлено ли средство OpenSSH. Если нет, выберите пункт Добавить компонент в верхней части страницы и сделайте следующее:
>    - Найдите Клиент OpenSSH и щелкните Установить.

Далее проблем с подключением у пользователей Windows быть не должно.

И так, продолжим.
Напомню, у нас открыт терминал и мы находимся в папке .ssh, напечатаем:

```bash
max@homepc:~/.ssh$  ssh-keygen
```

Генератор предложит вам указать уникальное название ключа, защитить его дополнительно паролем, и вроде бы будет еще пара вопросов, которые никто не читает.

Уникальное имя лучше придумать, это поможет когда ключей у вас станет больше чем один, а  с паролем решайте сами.

В итоге у вас будет два файла: 
server_key - это ваш приватный ключ, его необходимо оставить в папке .ssh вашей домашней директории, и никому никогда не передавать.
И server_key.pub - это, соответственно, публичная часть, содержимое которого необходимо загрузить при создании конфигурации нашей виртуальной машины.

Выведем содержимое публичного ключа и скопируем его в буфер обмена.

```bash
cat server_key.pub
```

Для удобства, большой точности и безопасности копирования в буфер можно воспользоваться утилитами xclip для Linux и pbcopy для MacOS.

#### Виртуальная машина в Yandex Cloud

Теперь откроем консоль [Yandex Cloud](https://console.cloud.yandex.ru/). Если у вас нет аккаунта, то его придется создать. Думаю, что с регистрацией на Яндекс проблем не возникнет.

Далее в меню слева выбираем раздел **Compute Cloud** и нажимаем кнопку **Создать ВМ**. Я специально решил делать этот пример на сервисах яндекса, поскольку у них есть подробное описание каждого пункта меню на русском языке.

Большинство параметров в этом примере мы оставим по умолчанию, либо выберем минимальные, поскольку при возникновении потребности в дальнейшем увеличить их не составит труда. 

Давайте быстро пройдемся по пунктам:

**Имя и описание** - все понятно, уникальное название и некоторые подробности, что бы вы сами не забыли что это за виртуалка крутится у вас в облаке.

**Зона доступности** - мне яндекс предложил **ru-central-b**, так и оставлю.

**Операционная система** - Ubuntu 20.04

**Диск** - HDD на 13 Gb

**Платформа** - Intel Ice Lake

**vCPU** - 2 (Количество ядер процессора, наверное хватило бы и одного, но яндекс так уже не предлагает)

**Гарантированная доля vCPU** - 20% (Минимальная гарантированная доля производительности. По моему опыту, при настройке загрузка ЦП не превышает 1-2%, так что этой доли нам более чем достаточно не только для настройки сервера, но и для небольших сервисов развернутых на нем.)

**RAM** - Очевидно оперативная память. Выбирайте минимум 2 GB

**Прерываемая** - самый спорный пункт. Его выбор делает большую скидку на ВМ, однако это дает право яндексу остановить ее в любой момент. Сервер будет остановлен коррекно, так что за сохранность данных переживать не стоит, но включать его обратно прийдется "вручную". Для этого урока я этот пункт включу, но если настраиваемый вами сервер планируется в дальнейшем использовать в рабочем режиме, то выбирать этот пункт точно не стоит.

В **сетевых настройках** нас интересует только пункт **Публичный адрес**, все остальное оставляем без изменений. 

Думаю здесь необходимо небольшое пояснение - в автоматическом режиме яндекс, конечно, предоставит публичный адрес, но проблема в том что при каждом перезапуске сервера он будет новым, что неприемлемо для настройки доменного имени. И да, это стоит отдельных денег, это нормально.  Постоянно зарезервированный адрес стоит немного дороже, чем автоматический, и еще дороже будет стоить зарезервированный, но неиспользуемый адрес. (На момент написания этой статьи это около 150 рублей в месяц.)

В любом случае, когда вы выберите пункт "список", то скорее всего получите сообщение о том, что в вашем облаке нет свободных статических IP-адресов. В конце этого сообщения будет ссылка с названием "список адресов", смело нажимаем на нее и попадаем в раздел Virtual Private Cloud. 

Выбираем в меню слева пункт "IP-адреса", и потом жмем на кнопку "Зарезервировать адрес", тут главное проследить что бы зона доступности, где резервируется адрес была той же, где создается сервер. Если все правильно - нажимаем "Зарезервировать" и возвращаемся к конфигурированию нашей ВМ.

Теперь при настройке публичного адреса в пункте список  будет доступен наш зарезервированный IP. Выберем его и перейдем к настройке доступа.

**Сервисный аккаунт** - нужен если вы планируете получать доступ с виртуальной машины к другим ресурсам облака. (Например к серверу базы данных). В данном случае в нем нет необходимости. 

**Логин** - имя пользователя в на сервере. Тут все просто, главное не выбирайте root или www-data. Я укажу просто max.

**SSH-ключ** - содержимое того самого server_key.pub, которое мы скопировали в буфер обмена. Просто вставьте его сюда.

**Доступ к серийной консоли не включаем.**  Считайте это аварийным режимом, при штатной работе сервера должен быть отключен.

Ну вот, теперь внимательно смотрим на правую колонку, и если цена нас устраивает - жмем на кнопку **Создать ВМ** внизу страницы.

#### Подключение к серверу

Наша  виртуальна машина готова. Поскольку мы еще не строили доменное имя, то давайте подключимся по IP

```bash
ssh max@178.154.219.150
```

Тут все просто: login@ip-adress

Login - Логин, который мы указали при конфигурации.

ip-adress - Зарезервированный за ВМ статический адрес.



Если вы создали пароль к своему ключу, то после нажатия enter вам предложат его ввести. Если все сделано правильно, то увидим подобное сообщение:

```bash
The authenticity of host 'example.com (178.154.219.150)' can't be established.
ECDSA key fingerprint is SHA256:7Q4nIqjuo/lSXWFkt9RaJYVHrT6LUAc6KWrdQ4/DDeA.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```

Все в порядке, так и должно быть, это сервер присылает отпечаток ключа для проверки. Просто напечатаем **yes** и нажмем enter еще раз.

Все, теперь мы видим приглашение командной строки нашей виртуальной машины. 

#### Установка утилит

Давайте для начала обновим данные о репозиториях:

```bash
sudo apt update
```

И, при необходимости, обновим сами пакеты:

```bash
sudo apt upgrade
```

Жмем (Y)es и немного подождем.

Кстати, пока идет обновление, обращу ваше внимание, что мы использовали **sudo**, для временного повышения  полномочий, но пароль запрошен не был.  Это странная особенность ВМ, и если вас это беспокоит - напишите, расскажу как это исправить.

Меня данная ситуация вполне устраивает, поэтому продолжаем. Большинство сервисов поставляют ВМ со схожим набором консольных утилит, но я предпочитаю все же выполнить установку одной строкой все требуемых мне, а не проверять их наличие по отдельности. Если что то из этого уже установлено - установщик просто пропустит этот шаг.

```bash
sudo apt install mc git curl wget rsync zip unzip
```

Опять же жмем (Y)es и немного подождем.

И что бы не терять время пройдемся по утилитам:

**mc** - Midnight Commander, консольный двух-панельный файловый менеджер. Большинство операций, я выполняю через него.

**git** - тот самый гит, очень пригодится, если захотим что нибудь клонировать с гитхаб или битбакет. Ну или наоборот отправить туда.

**curl** - Мне кажется не существует сетевого протокола, по которому эта утилита не могла бы послать запрос прямо из командной строки. 

**wget** - качает файлы по ссылке. Можно конечно качать и с помощью curl, но эта мне как то привычнее.

**rsync** - удобная синхронизация файлов и каталогов, можно запускать по расписанию.

**zip** и  **unzip** - очевидно архиваторы zip. Родные архиваторы  bzip2 и gzip как правило есть всегда, а эти бывает, что и не установлены на старте.

#### Сервер SSH

Давайте откроем настройки сервера SSH. Это можно сделать напечатав в командной строке:

```bash
sudo nano /etc/ssh/sshd_config
```

Либо запустив midnight commander, найти, выделить файл и нажать F4. При первом запуске МС попросить выбрать предпочитаемый редактор, рекомендую выбрать **nano**

```bash
sudo mc
```

И да, большую часть команд и правок мы будем вносить используя **sudo**, (Substitute User and do, дословно «подменить пользователя и выполнить»). Это необходимо для повышения наших полномочий до уровня root

Давайте взглянем на конфигурационный файл. Большинство строк с параметрами комментированы символом **#**, предполагается, что значения указанные в них - будут использованы по умолчанию. Давайте вспомним старый принцип программирования - "явное лучше чем неявное", и пройдемся по параметрам, которые я считаю важным указать явным способом.

Давайте пробежимся по файлу сверху вниз, и первый параметр который нам нужен выглядит так: 

```bash
#PermitRootLogin prohibit-password
```

Очевидно из названия - разрешить руту логинится удаленно с использованием непарольных методов аутентификации. Сканер отпечатков, смарт-карта и т.д.

Раскомментируем строку и ставим значение в **no**:

```bash
PermitRootLogin no
```

Никаких удаленных авторизаций для root



Следующий параметр за возможность авторизации по SSH ключу. Мы именно так и зашли на наш сервер. 

```
PubkeyAuthentication yes
```

Укажем это явно, оставляем **yes** по умолчанию, просто удалим знак комментария.



Дальше будет длинная строка с параметрами отделенными табуляцией:

```
#AuthorizedKeysFile     .ssh/authorized_keys .ssh/authorized_keys2
```

Это указание на то где искать файл с публичными ключами для авторизации пользователей. Оставляем как есть, просто раскомментируем.



И последний обязательный пункт:

```
#PasswordAuthentication yes
```

Удаляем символ комментария и устанавливаем параметр в **no**. Никаких парольных идентификаций, только файлы ключей.

```
PasswordAuthentication no
```



И последний, не скажу, что обязательный параметр, просто убедитесь, что он выглядит именно так:

```
X11Forwarding yes
```

Если на сервер нужно будет установить GUI, он поможет перенаправить вывод графической части приложения на вашу локальную машину.



Все. Теперь нажимаем Ctrl + X и подтверждаем запись файла.

Если вы использовали midnight commander то нажмите Ctrl + O, это скроет панели, отобразив терминал, но не закроет сам MC, так же как и не прервет сессию **sudo**. Повторное нажатие вернет панели обратно.

Перезапустим наш сервис SSH, что бы применить внесенные изменения.

```bash
sudo systemctl restart ssh
```

Можно отключится напечатав **exit**, и подключится опять, для проверки работоспособности, он это необязательно.



#### Устанавливаем Nginx

Именно он будет отвечать за прием входящих запросов и проксированием их в глубь нашего сервера.

Никаких дополнительных модулей устанавливать не планируется, поэтому просто ставим из стандартного репозитория:

```bash
sudo apt install nginx
```

И стразу же проверим его статус:

```bash
sudo systemctl status nginx
```

Все.

Работает. Да, мы еще не настроили доменное имя, но если мы откроем браузер и введем там внешний IP нашей виртуальной машины, то мы увидим стандартную страницу приветствия Nginx. Так же можно воспользоваться утилитой **curl**, не зря же мы ее ставили.

```bash
curl 178.154.219.150
```

178.154.219.150 - вам следует заменить на свой.

Стандартный HTML лежит в папке **/var/www/html**, при желании можете его заменить на любой другой. Мы в рамках данной инструкции делать этого не будем, поскольку использование данной папки в дальнейшем не планируется.

Все нормально, сервер запущен и работает, а его дальнейшую настройку оставим на потом. 



Разве что укажу сразу основные команды, которые необходимо знать при работе с Nginx:



Самая главная команда, которую будем использовать даже чаще чем запрос статуса:

```bash
sudo nginx -t
```

Это тестирование конфигурации, ее необходимо использовать после каждого внесения изменений в конфигурационные файлы, Nginx проведет проверку их синтаксиса и сообщит, если что то не так. Лучше об этом узнать сейчас, чем во время отказа при запуске.



Кстати о перезагрузке. Почему то многие советуют использовать системный метод:

```bash
sudo systemctl restart nginx
```

Эта команда целиком остановит и запустит заново все службу, разорвав все текущие соединения, что не всегда хорошо. Точнее всегда не хорошо. 

Вы можете сказать, а какая разница, ну нажмет пользователь обновить страницу, а многие может и вообще не заметят этих секунд перезагрузки. Опять же верно, но отчасти. А представьте, что у нас на базе этого сервера работает приложение, которое пишет игровую статистику вашей же разработанной игры? Например получает json файл с новым пользовательским рекордом, и готовится записать его в базу данных. А тут раз, и все потухло. Рекорд не записан, игра напрасно ждет ответа от сервера о статусе операции, пользователь страдает. Или у нас работает бек-энд бота для телеграма или навыка Яндекс Алисы, а там вообще время ожидания 2 и 3 секунды. Получится, что пользователь спросил что то у колонки, а в ответ тишина, Яндекс ждет 2 секунды и отключает сеанс с навыком. Не очень хорошо, согласитесь?

В общем, используйте этот метод только в том случае, когда точно понимаете зачем это делать.

В большинстве же случаев достаточно мягкой перезагрузки, без остановки самого сервиса:

```bash
sudo systemctl reload nginx
```

Либо воспользоваться внутренней командой самого Nginx:

(Да и официальная документация рекомендует именно ее).

```bash
sudo nginx -s reload
```

Это позволит серверу протестировать новую конфигурацию, и если все в порядке - Nginx начнет  запускать новые процессы уже с ней, завершая старые в рабочем порядке. При таком способе подключения пользователей разорваны не будут.



Ну и давайте убедимся, что наш веб-сервер будет запущен при старте операционной системы:

```bash
sudo systemctl is-enabled nginx
```

Если все в порядке - двигаемся дальше, если нет, то добавим его в автозагрузку:

```bash
sudo systemctl enable nginx
```

#### Некий промежуточный итог

На сервер работает. 

Мы даже сделали немного больше, установив в него nginx. Лично для себя, я в этом месте подвожу некую условную черту, когда от общих настроек переходим к некоторым вариациям, зависящим от стоящих перед сервером задач.

Например, нет необходимости активировать файрвол, если планируется использование специальных групп безопасности (***\*security\**** ***\*groups\****) работающих на уровне инстанса ВМ. Либо нет смысла настраивать защищенное соединение по 443 порту, если сервер будет работать где то во внутреннем кластере, получая трафик только вышестоящего nginx, выполняющего роль балансировщика нагрузки. 

Но давайте продолжим двигаться к нашей цели, а именно сервер для Flask приложения.

#### Настройка UFW

Не смотря на свое название Uncomplicated FireWall, это все таки не файрвол, а оболочка для стандартного для Linux брандмауэра iptables. А вот то, что он действительно Uncomplicated (несложный, незапутанный) это правда. 

Начнем сначала. Проверим наличие ufw:

```bash
sudo uwf status
```

Если получили сведения о состоянии, например **неактивен**, то все в порядке, двигаемся дальше. Если нет - то его необходимо установить:

```bash
sudo apt install ufw
```



Тут мне кажется необходимо сделать важную оговорку - не торопитесь его активировать, поскольку вы потеряете возможность удаленного доступа к серверу. Сначала крайне важно убедится в корректности настроек правил фильтрации.



Поскольку в планах включить поддержку IPV6 на нашем веб-сервере, то нам нужно убедится, что в нашем файрволе она включена:

Для этого откроем файл с конфигурацией:

```bash
sudo nano /etc/default/ufw
```

Нас интересует первый же параметр. Убедитесь, что и у вас он имеет значение **yes**:

```bash
IPV6=yes
```

Сохраняем и закрываем файл конфигурации. Если вы как и я используете редактор nano, то просто нажмите Ctrl+x



Итак, фильтрация.

Если вы просмотрели файл выше, то могли заметить, что по умолчанию все входящие пакеты отбрасываются:

```
DEFAULT_INPUT_POLICY="DROP"
```

Нас это не устраивает, поскольку необходимо разрешить как минимум доступ по SSH, HTTP и HTTPS.

Не торопитесь открывать файл конфигурации, он более нам не нужен. Мы сделаем это по другому. 

Помимо создания правил фильтрации непосредственно для портов или стандартных приложений прямо из командной строки UFW умеет управлять доступами для приложений с помощью  специальных файлов-конфигураций.

Список доступных приложений можно посмотреть так:

```bash
sudo ufw app list
```

Если вы двигались вместе со мной, то вы скорее всего увидите записи для **nginx**  и **openssh**, которые созданы автоматически при их обнаружении в системе. 

```bash
Available applications:
  Flask
  Nginx Full
  Nginx HTTP
  Nginx HTTPS
  OpenSSH
```



Сами файлы лежат в отдельном каталоге, давайте посмотрим его содержимое:

```bash
ls -la /etc/ufw/applications.d
```

(Либо просто откройте его через MC)

Мы опять же видим два файла **nginx**  и **openssh-server**, которые созданы автоматически при обнаружении, и содержание которых перечислила нам предыдущая команда.

Просмотрев любой из них, мы поймем, что синтаксис предельно прост:

**[Nginx HTTP]** - Название раздела. Это то, что нам покажет команда `sudo ufw app list`
**title=** - Заголовок
**description=** - Описание раздела
**ports=** - Порты, которые необходимо открыть для сервиса



Очевидно, что файл может быть один, с кучей разделов, но это не правильно, рекомендуется создавать отдельный файл для каждого сервиса.



Вооружившись этими знаниями создадим третий файл конфигурации для нашего development сервера Flask. Это будет временное разрешение, созданное для показательного примера, после запуска сервера в рабочем режиме правило должно быть отключено.

Итак, создадим пустой файл:

```bash
sudo nano /etc/ufw/applications.d/flask
```

И наполним его таким содержимым:

```bash
[Flask]
title=Flask server
description=Flask development server, do not use it on prodaction
ports=5000/tcp
```

Сохраняем, выходим. И давайте еще раз посмотрим на список приложений:

```bash
sudo ufw app list
```

И мы видим, что наше приложение Flask было добавлено в список доступных для фильтрации.

```bash
Available applications:
  Flask
  Nginx Full
  Nginx HTTP
  Nginx HTTPS
  OpenSSH
```



Но следует помнить, что добавление приложения в эти файла, не включает доступ к нему автоматически, это делается отдельной командой:

```bash
sudo ufw allow 'название сервиса'
```

Так что давайте включим некоторые правила на нашем сервере:

Первое и самое важное, повторюсь - без него, при активации UFW мы потерям возможность удаленного доступа.

```bash
sudo ufw allow OpenSSH
```

Далее разрешим порты веб-сервера:

```bash
sudo ufw allow 'Nginx Full'
```

И наш тестовый Flask

```bash
sudo ufw allow Flask
```

Обратите внимание, там где в названиях присутствовали пробелы, я использовал одинарные кавычки.



Вот теперь мы можем включить наш файрволл:

```bash
sudo ufw enable
```

Все, теперь ни один сервис кроме трех наших приложений не сможет принять подключение снаружи.



Удаляется правило аналогично:

```bash
sudo ufw delete allow 'название сервиса'
```

Либо можно получить нумерованный список правил:

```bash
sudo ufw status numbered
```

И удалить его по номеру:

```bash
sudo ufw delete номер
```



Целиком UFW можно отключить:

```bash
sudo ufw disable
```



В качестве бонуса.

Сброс настроек:

```bash
sudo ufw reset
```

Если не уверены в команде, добавьте добавьте этот ключ.

**--dry-run**

Он означает тестовый запуск, без применения реальных действий.



#### Есть что дополнить?

[](https://github.com/trash-max/howto)

